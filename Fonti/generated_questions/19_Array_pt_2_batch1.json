[
    {
        "category": "Informatica",
        "question": "Passaggio array a funzione (C):",
        "options": [
            "Per riferimento (indirizzo del primo elemento)",
            "Per valore (copia intero array)",
            "Per nome",
            "Nulla"
        ],
        "answer": "Per riferimento (indirizzo del primo elemento)"
    },
    {
        "category": "Informatica",
        "question": "Cosa riceve la funzione quando si passa un array?",
        "options": [
            "Un puntatore al tipo degli elementi dell'array",
            "L'array intero",
            "Una copia",
            "Nulla"
        ],
        "answer": "Un puntatore al tipo degli elementi dell'array"
    },
    {
        "category": "Informatica",
        "question": "Modificare un elemento dell'array in una funzione:",
        "options": [
            "Modifica l'array originale (side effect)",
            "Modifica solo la copia locale",
            "Non ha effetto",
            "Nulla"
        ],
        "answer": "Modifica l'array originale (side effect)"
    },
    {
        "category": "Informatica",
        "question": "Parametro formale int a[] vs int *a:",
        "options": [
            "Sono equivalenti nel contesto dei parametri di funzione",
            "Sono diversi",
            "Errore",
            "Nulla"
        ],
        "answer": "Sono equivalenti nel contesto dei parametri di funzione"
    },
    {
        "category": "Informatica",
        "question": "Come passare la dimensione dell'array a una funzione?",
        "options": [
            "Come parametro aggiuntivo (es. int size)",
            "Non serve",
            "È automatico",
            "Nulla"
        ],
        "answer": "Come parametro aggiuntivo (es. int size)"
    },
    {
        "category": "Informatica",
        "question": "Perché passare la dimensione?",
        "options": [
            "Perché sizeof sull'array decaduto a puntatore restituisce la dimensione del puntatore, non dell'array",
            "Per bellezza",
            "Non serve",
            "Nulla"
        ],
        "answer": "Perché sizeof sull'array decaduto a puntatore restituisce la dimensione del puntatore, non dell'array"
    },
    {
        "category": "Informatica",
        "question": "Restituire un array da una funzione:",
        "options": [
            "Non si può restituire un array statico locale (dangling pointer). Si può restituire un puntatore (es. a memoria malloc o static)",
            "Si può sempre",
            "Mai",
            "Nulla"
        ],
        "answer": "Non si può restituire un array statico locale (dangling pointer). Si può restituire un puntatore (es. a memoria malloc o static)"
    },
    {
        "category": "Informatica",
        "question": "Array statico locale:",
        "options": [
            "Allocato nello stack, distrutto al ritorno della funzione",
            "Allocato nello heap",
            "Globale",
            "Nulla"
        ],
        "answer": "Allocato nello stack, distrutto al ritorno della funzione"
    },
    {
        "category": "Informatica",
        "question": "Puntatore aritmetica (p + 1):",
        "options": [
            "Avanza di sizeof(tipo puntato) byte (elemento successivo)",
            "Avanza di 1 byte",
            "Avanza di 1 bit",
            "Nulla"
        ],
        "answer": "Avanza di sizeof(tipo puntato) byte (elemento successivo)"
    },
    {
        "category": "Informatica",
        "question": "Accesso array con puntatori:",
        "options": [
            "*(p + i) è equivalente a p[i]",
            "p + i",
            "&p[i]",
            "Nulla"
        ],
        "answer": "*(p + i) è equivalente a p[i]"
    },
    {
        "category": "Informatica",
        "question": "Array multidimensionale come parametro:",
        "options": [
            "Bisogna specificare tutte le dimensioni tranne la prima (es. int m[][10])",
            "Nessuna dimensione",
            "Tutte le dimensioni",
            "Nulla"
        ],
        "answer": "Bisogna specificare tutte le dimensioni tranne la prima (es. int m[][10])"
    },
    {
        "category": "Informatica",
        "question": "Perché specificare dimensioni array multidimensionale?",
        "options": [
            "Per calcolare correttamente l'indirizzo (row-major mapping)",
            "Per controllo",
            "Non serve",
            "Nulla"
        ],
        "answer": "Per calcolare correttamente l'indirizzo (row-major mapping)"
    },
    {
        "category": "Informatica",
        "question": "Costante array:",
        "options": [
            "Il nome dell'array è un puntatore costante (non riassegnabile)",
            "Variabile",
            "Modificabile",
            "Nulla"
        ],
        "answer": "Il nome dell'array è un puntatore costante (non riassegnabile)"
    },
    {
        "category": "Informatica",
        "question": "Differenza array vs puntatore:",
        "options": [
            "Array alloca memoria per elementi. Puntatore alloca memoria solo per indirizzo.",
            "Sono uguali",
            "Nulla",
            "Errore"
        ],
        "answer": "Array alloca memoria per elementi. Puntatore alloca memoria solo per indirizzo."
    },
    {
        "category": "Informatica",
        "question": "String literal (\"ciao\"):",
        "options": [
            "Array di char statico (spesso read-only)",
            "Variabile",
            "Puntatore",
            "Nulla"
        ],
        "answer": "Array di char statico (spesso read-only)"
    },
    {
        "category": "Informatica",
        "question": "char *s = \"ciao\"; vs char s[] = \"ciao\";",
        "options": [
            "*s punta a stringa costante (non modificabile). s[] è un array modificabile (copia).",
            "Sono uguali",
            "Entrambi modificabili",
            "Nulla"
        ],
        "answer": "*s punta a stringa costante (non modificabile). s[] è un array modificabile (copia)."
    },
    {
        "category": "Informatica",
        "question": "Array di puntatori:",
        "options": [
            "Array dove ogni elemento è un puntatore (es. char *argv[])",
            "Puntatore ad array",
            "Matrice",
            "Nulla"
        ],
        "answer": "Array dove ogni elemento è un puntatore (es. char *argv[])"
    },
    {
        "category": "Informatica",
        "question": "Puntatore ad array:",
        "options": [
            "Puntatore che punta a un intero array (int (*p)[10])",
            "Array di puntatori",
            "Puntatore int",
            "Nulla"
        ],
        "answer": "Puntatore che punta a un intero array (int (*p)[10])"
    },
    {
        "category": "Informatica",
        "question": "Allocazione dinamica array (malloc):",
        "options": [
            "int *p = malloc(n * sizeof(int));",
            "int p[n];",
            "new int[n]",
            "Nulla"
        ],
        "answer": "int *p = malloc(n * sizeof(int));"
    },
    {
        "category": "Informatica",
        "question": "calloc:",
        "options": [
            "Alloca memoria e la inizializza a zero (malloc + memset)",
            "malloc",
            "realloc",
            "Nulla"
        ],
        "answer": "Alloca memoria e la inizializza a zero (malloc + memset)"
    },
    {
        "category": "Informatica",
        "question": "realloc:",
        "options": [
            "Ridimensiona un blocco di memoria precedentemente allocato (può spostarlo)",
            "malloc",
            "free",
            "Nulla"
        ],
        "answer": "Ridimensiona un blocco di memoria precedentemente allocato (può spostarlo)"
    },
    {
        "category": "Informatica",
        "question": "free:",
        "options": [
            "Libera memoria allocata dinamicamente",
            "Cancella",
            "Pulisce",
            "Nulla"
        ],
        "answer": "Libera memoria allocata dinamicamente"
    },
    {
        "category": "Informatica",
        "question": "Matrice dinamica (array di puntatori):",
        "options": [
            "Allocare array di puntatori alle righe, poi allocare ogni riga",
            "Malloc unica",
            "Array statico",
            "Nulla"
        ],
        "answer": "Allocare array di puntatori alle righe, poi allocare ogni riga"
    },
    {
        "category": "Informatica",
        "question": "Matrice dinamica (linearizzata):",
        "options": [
            "Allocare unico blocco di dimensione R*C e accedere con [i*C + j]",
            "Array puntatori",
            "Lista",
            "Nulla"
        ],
        "answer": "Allocare unico blocco di dimensione R*C e accedere con [i*C + j]"
    },
    {
        "category": "Informatica",
        "question": "Deep copy vs Shallow copy:",
        "options": [
            "Deep: copia i dati puntati (nuova memoria). Shallow: copia solo i puntatori (condivide memoria).",
            "Sono uguali",
            "Shallow è meglio",
            "Nulla"
        ],
        "answer": "Deep: copia i dati puntati (nuova memoria). Shallow: copia solo i puntatori (condivide memoria)."
    },
    {
        "category": "Informatica",
        "question": "memcpy:",
        "options": [
            "Copia blocco di memoria da src a dest (veloce)",
            "Copia stringa",
            "Sposta",
            "Nulla"
        ],
        "answer": "Copia blocco di memoria da src a dest (veloce)"
    },
    {
        "category": "Informatica",
        "question": "memmove:",
        "options": [
            "Come memcpy ma sicuro se le aree di memoria si sovrappongono",
            "memcpy",
            "Sposta",
            "Nulla"
        ],
        "answer": "Come memcpy ma sicuro se le aree di memoria si sovrappongono"
    },
    {
        "category": "Informatica",
        "question": "memset:",
        "options": [
            "Imposta un blocco di memoria a un valore specifico (es. 0)",
            "Setta",
            "Copia",
            "Nulla"
        ],
        "answer": "Imposta un blocco di memoria a un valore specifico (es. 0)"
    },
    {
        "category": "Informatica",
        "question": "memcmp:",
        "options": [
            "Confronta due blocchi di memoria",
            "Confronta stringhe",
            "Copia",
            "Nulla"
        ],
        "answer": "Confronta due blocchi di memoria"
    },
    {
        "category": "Informatica",
        "question": "Buffer circolare (Ring buffer):",
        "options": [
            "Struttura dati a dimensione fissa dove la fine è collegata all'inizio (utile per code)",
            "Array",
            "Lista",
            "Nulla"
        ],
        "answer": "Struttura dati a dimensione fissa dove la fine è collegata all'inizio (utile per code)"
    },
    {
        "category": "Informatica",
        "question": "Sparse Matrix:",
        "options": [
            "Matrice con maggior parte degli elementi a zero (memorizzata efficientemente)",
            "Matrice densa",
            "Array",
            "Nulla"
        ],
        "answer": "Matrice con maggior parte degli elementi a zero (memorizzata efficientemente)"
    },
    {
        "category": "Informatica",
        "question": "Jagged Array:",
        "options": [
            "Array di array dove le righe possono avere lunghezze diverse",
            "Matrice rettangolare",
            "Cubo",
            "Nulla"
        ],
        "answer": "Array di array dove le righe possono avere lunghezze diverse"
    },
    {
        "category": "Informatica",
        "question": "Stride (Array):",
        "options": [
            "Passo di avanzamento in memoria tra elementi consecutivi (importante per cache)",
            "Salto",
            "Dimensione",
            "Nulla"
        ],
        "answer": "Passo di avanzamento in memoria tra elementi consecutivi (importante per cache)"
    },
    {
        "category": "Informatica",
        "question": "Cache locality:",
        "options": [
            "Principio per cui accedere a memoria contigua è più veloce (sfrutta cache CPU)",
            "Velocità",
            "Memoria",
            "Nulla"
        ],
        "answer": "Principio per cui accedere a memoria contigua è più veloce (sfrutta cache CPU)"
    },
    {
        "category": "Informatica",
        "question": "Spatial locality:",
        "options": [
            "Se accedi a un indirizzo, è probabile che accederai a quelli vicini",
            "Temporale",
            "Nulla",
            "Errore"
        ],
        "answer": "Se accedi a un indirizzo, è probabile che accederai a quelli vicini"
    },
    {
        "category": "Informatica",
        "question": "Temporal locality:",
        "options": [
            "Se accedi a un indirizzo, è probabile che ci accederai di nuovo presto",
            "Spaziale",
            "Nulla",
            "Errore"
        ],
        "answer": "Se accedi a un indirizzo, è probabile che ci accederai di nuovo presto"
    },
    {
        "category": "Informatica",
        "question": "Cache miss:",
        "options": [
            "Quando il dato richiesto non è in cache e deve essere recuperato dalla RAM (lento)",
            "Cache hit",
            "Errore",
            "Nulla"
        ],
        "answer": "Quando il dato richiesto non è in cache e deve essere recuperato dalla RAM (lento)"
    },
    {
        "category": "Informatica",
        "question": "Row-major vs Column-major performance:",
        "options": [
            "Iterare secondo il layout di memoria (es. per righe in C) minimizza cache miss",
            "Uguale",
            "Colonna meglio",
            "Nulla"
        ],
        "answer": "Iterare secondo il layout di memoria (es. per righe in C) minimizza cache miss"
    },
    {
        "category": "Informatica",
        "question": "Array bounds checking hardware:",
        "options": [
            "Alcune architetture/linguaggi lo supportano, C no (overhead)",
            "Sempre attivo",
            "Mai",
            "Nulla"
        ],
        "answer": "Alcune architetture/linguaggi lo supportano, C no (overhead)"
    },
    {
        "category": "Informatica",
        "question": "Sentinel value (stringhe):",
        "options": [
            "Il carattere nullo '\\0' è la sentinella per le stringhe C",
            "-1",
            "EOF",
            "Nulla"
        ],
        "answer": "Il carattere nullo '\\0' è la sentinella per le stringhe C"
    },
    {
        "category": "Informatica",
        "question": "Funzione variadica (va_list):",
        "options": [
            "Meccanismo per accedere agli argomenti variabili (es. in printf)",
            "Lista",
            "Array",
            "Nulla"
        ],
        "answer": "Meccanismo per accedere agli argomenti variabili (es. in printf)"
    },
    {
        "category": "Informatica",
        "question": "va_start:",
        "options": [
            "Inizializza la va_list",
            "Inizia",
            "Finisce",
            "Nulla"
        ],
        "answer": "Inizializza la va_list"
    },
    {
        "category": "Informatica",
        "question": "va_arg:",
        "options": [
            "Recupera il prossimo argomento dalla va_list",
            "Argomento",
            "Lista",
            "Nulla"
        ],
        "answer": "Recupera il prossimo argomento dalla va_list"
    },
    {
        "category": "Informatica",
        "question": "va_end:",
        "options": [
            "Pulisce la va_list",
            "Finisce",
            "Inizia",
            "Nulla"
        ],
        "answer": "Pulisce la va_list"
    },
    {
        "category": "Informatica",
        "question": "Designated initializers (C99):",
        "options": [
            "Inizializzare elementi specifici array/struct (es. .x = 1, [0] = 5)",
            "Inizializzazione",
            "Design",
            "Nulla"
        ],
        "answer": "Inizializzare elementi specifici array/struct (es. .x = 1, [0] = 5)"
    },
    {
        "category": "Informatica",
        "question": "Compound literal (C99):",
        "options": [
            "Creare array/struct anonimi al volo (es. (int[]){1, 2})",
            "Letterale",
            "Composto",
            "Nulla"
        ],
        "answer": "Creare array/struct anonimi al volo (es. (int[]){1, 2})"
    },
    {
        "category": "Informatica",
        "question": "Flexible array member (C99):",
        "options": [
            "Ultimo membro di struct array[] senza dimensione (per struct a dimensione variabile)",
            "Array flessibile",
            "Membro",
            "Nulla"
        ],
        "answer": "Ultimo membro di struct array[] senza dimensione (per struct a dimensione variabile)"
    },
    {
        "category": "Informatica",
        "question": "Restrict keyword (C99):",
        "options": [
            "Promessa al compilatore che un puntatore è l'unico accesso a quell'area (ottimizzazione)",
            "Restrizione",
            "Puntatore",
            "Nulla"
        ],
        "answer": "Promessa al compilatore che un puntatore è l'unico accesso a quell'area (ottimizzazione)"
    },
    {
        "category": "Informatica",
        "question": "Aliasing:",
        "options": [
            "Quando due puntatori diversi puntano alla stessa area di memoria (impedisce ottimizzazioni)",
            "Alias",
            "Nome",
            "Nulla"
        ],
        "answer": "Quando due puntatori diversi puntano alla stessa area di memoria (impedisce ottimizzazioni)"
    },
    {
        "category": "Informatica",
        "question": "Strict Aliasing Rule:",
        "options": [
            "Regola C che vieta di accedere alla stessa memoria con puntatori di tipi incompatibili",
            "Regola",
            "Aliasing",
            "Nulla"
        ],
        "answer": "Regola C che vieta di accedere alla stessa memoria con puntatori di tipi incompatibili"
    }
]